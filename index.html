<!DOCTYPE html>
<html>
<head>
  <title>Escape Maze!!</title>
  <link rel="icon" type="image/png" href="assets/favicon.ico">
  <style>
    #maze-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 800px;
      height: 600px;
    }

    #start-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 999;
    }

    #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 999;
      display: none;
    }

    #game-over p {
      color: white;
      font-size: 24px;
      margin-bottom: 10px;
    }

    #game-over button {
      padding: 10px 20px;
      background-color: #4caf50;
      border: none;
      color: white;
      font-weight: bold;
      cursor: pointer;
    }

    #minimap-container {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 200px;
      height: 200px;
      background-color: #333;
    }

    #minimap-grid {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .minimap-cell {
      box-sizing: border-box;
      border: 1px solid #555;
      float: left; /* Added this line */
    }

    .visited {
      background-color: #aaa;
    }

    .player {
      background-color: red;
    }

    .portal {
      background-color: blue;
    }
  </style>
</head>
<body>
  <div id="maze-container">
    <div id="start-screen">
      <h1>Welcome to Escape Maze!</h1>
      <p>Please select the dimensions of the maze:</p>
      <input type="number" id="maze-width" min="8" max="30" placeholder="Width" value="8"/>
      <input type="number" id="maze-height" min="8" max="30" placeholder="Height" value="8"/>
      <button onclick="randomizeDimensions()">Random</button>

      <button id="start-button">Start Game</button>
    </div>
  </div>

  <div id="minimap-container">
    <div id="minimap-grid"></div>
  </div>


  <div id="game-over">
    <p id="game-over-text"></p>
    <button id="restart-button">Restart Game</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
  <script>
    let startTime;

    let mazeWidth = 0;
    let mazeHeight = 0;

    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over');
    const gameOverText = document.getElementById('game-over-text');
    const restartButton = document.getElementById('restart-button');
    const mazeContainer = document.getElementById('maze-container');
    const mazeWidthInput = document.getElementById('maze-width');
    const mazeHeightInput = document.getElementById('maze-height');
    const startButton = document.getElementById('start-button');

    startButton.addEventListener('click', () => {
      mazeWidth = parseInt(mazeWidthInput.value);
      mazeHeight = parseInt(mazeHeightInput.value);
      startScreen.style.display = 'none';
      mazeContainer.style.display = 'block';
      initializeMaze();
    });

    const gameOver = () => {
      const timeTaken = calculateTimeTaken();
      gameOverText.textContent = `Congratulations!\nYou took ${timeTaken} seconds to clear the maze`;
      gameOverScreen.style.display = 'flex';
      mazeContainer.style.pointerEvents = 'none';
    };

    const calculateTimeTaken = () => {
      const currentTime = new Date();
      const timeDiff = Math.round((currentTime - startTime) / 1000);
      return timeDiff;
    };

    restartButton.addEventListener("click", () => {
      location.reload();
    });


    function randomizeDimensions() {
      mazeWidth = Math.floor(Math.random() * 22) + 8;
      mazeHeight = Math.floor(Math.random() * 22) + 8;
      startScreen.style.display = 'none';
      mazeContainer.style.display = 'block';
      initializeMaze();
    }


    function initializeMaze() {
      startTime = Date.now();
      const cellSize = 50;

      let portalRow, portalCol;

      const maze = generateRandomMaze(mazeWidth, mazeHeight);
      console.log(maze);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(800, 600);
      document.getElementById('maze-container').appendChild(renderer.domElement);

      const groundTexture = new THREE.TextureLoader().load('assets/textures/old-wood.jpg');
      const wallTexture = new THREE.TextureLoader().load('assets/textures/old-wood-2.jpg');
      const ceilingTexture = new THREE.TextureLoader().load('assets/textures/ceilings.png');
      const portalTexture = new THREE.TextureLoader().load('assets/textures/portal.jpg');

      const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture });
      const floorMaterial = new THREE.MeshBasicMaterial({ map: groundTexture });
      const ceilingMaterial = new THREE.MeshBasicMaterial({ map: ceilingTexture });
      const portalMaterial = new THREE.MeshBasicMaterial({ map: portalTexture });

      for (let row = 0; row < mazeHeight; row++) {
        for (let col = 0; col < mazeWidth; col++) {
          const cell = maze[row][col];
          if (cell === 1) {
            const wall = new THREE.BoxGeometry(cellSize, cellSize * 2, cellSize);
            const wallMesh = new THREE.Mesh(wall, wallMaterial);
            wallMesh.position.x = col * cellSize - (mazeWidth / 2) * cellSize + cellSize / 2;
            wallMesh.position.y = cellSize;
            wallMesh.position.z = row * cellSize - (mazeHeight / 2) * cellSize + cellSize / 2;
            wallMesh.mazeWall = true;
            scene.add(wallMesh);
          } else {
            const floor = new THREE.PlaneGeometry(cellSize, cellSize);
            const floorMesh = new THREE.Mesh(floor, floorMaterial);
            floorMesh.position.x = col * cellSize - (mazeWidth / 2) * cellSize + cellSize / 2;
            floorMesh.position.y = 0;
            floorMesh.position.z = row * cellSize - (mazeHeight / 2) * cellSize + cellSize / 2;
            floorMesh.rotation.x = -Math.PI / 2;
            scene.add(floorMesh);

            const ceiling = new THREE.PlaneGeometry(cellSize, cellSize);
            const ceilingMesh = new THREE.Mesh(ceiling, ceilingMaterial);
            ceilingMesh.position.x = col * cellSize - (mazeWidth / 2) * cellSize + cellSize / 2;
            ceilingMesh.position.y = cellSize * 2;
            ceilingMesh.position.z = row * cellSize - (mazeHeight / 2) * cellSize + cellSize / 2;
            ceilingMesh.rotation.x = Math.PI / 2;
            scene.add(ceilingMesh);

            if (cell == 2) {
              camera.position.set(floorMesh.position.x, cellSize / 2, floorMesh.position.z );
            }

            if (cell == 3) {
              const portal = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
              const portalMesh = new THREE.Mesh(portal, portalMaterial);
              portalMesh.position.x = col * cellSize - (mazeWidth / 2) * cellSize + cellSize / 2;
              portalMesh.position.y = cellSize/2;
              portalMesh.position.z = row * cellSize - (mazeHeight / 2) * cellSize + cellSize / 2;
              portalMesh.mazePortal = true;
              scene.add(portalMesh);
              portalRow = row;
              portalCol = col;
            }
          }
        }
      }

      const playerControls = {
        moveForward: false,
        moveBackward: false,
        moveLeft: false,
        moveRight: false,
      };

      let isMousePressed = false;
      let previousMouseX = 0;

      document.addEventListener('keydown', (event) => {
        handlePlayerControls(event.keyCode, true);
      });

      document.addEventListener('keyup', (event) => {
        handlePlayerControls(event.keyCode, false);
      });

      document.addEventListener('mousedown', (event) => {
        if (event.button === 0) {
          isMousePressed = true;
          previousMouseX = event.clientX;
        }
      });

      document.addEventListener('mouseup', (event) => {
        if (event.button === 0) {
          isMousePressed = false;
        }
      });

      document.addEventListener('mousemove', (event) => {
        if (isMousePressed) {
          const mouseDeltaX = event.clientX - previousMouseX;
          previousMouseX = event.clientX;
          rotateCameraX(mouseDeltaX);
        }
      });


      function handlePlayerControls(keyCode, isPressed) {
        switch (keyCode) {
          case 87: // W key
            playerControls.moveForward = isPressed;
            break;
          case 38: // Arrow up
            handleKeyPress(38);
            break;
          case 83: // S key
            playerControls.moveBackward = isPressed;
            break;
          case 40: // Arrow down
            handleKeyPress(40);
            break;
          case 65: // A key
            playerControls.moveLeft = isPressed;
            break;
          case 37: // Arrow left
            handleKeyPress(37);
            break;
          case 68: // D key
            playerControls.moveRight = isPressed;
            break;
          case 39: // Arrow right
            handleKeyPress(39);
            break;
          default:
            break;
        }
      }

      function handleKeyPress(keyCode) {

        const gameContainer = document.getElementById('game-container');

        let cameraPositionX = gameContainer.scrollLeft;
        let cameraPositionY = gameContainer.scrollTop;

        const gameContainerWidth = gameContainer.offsetWidth;
        const gameContainerHeight = gameContainer.offsetHeight;

        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        const windowCenterX = windowWidth / 2;
        const windowCenterY = windowHeight / 2;

        const gameCenterX = gameContainerWidth / 2;
        const gameCenterY = gameContainerHeight / 2;

        if (keyCode === 38) { // PgUp
          cameraPositionY -= windowCenterY;
        } else if (keyCode === 40) { // PgDown
          cameraPositionY += windowCenterY;
        } else if (keyCode === 37) { // PgLeft
          cameraPositionX -= windowCenterX;
        } else if (keyCode === 39) { // PgRight
          cameraPositionX += windowCenterX;
        }

        const newCameraPositionX = Math.max(0, Math.min(cameraPositionX, gameContainerWidth - windowWidth));
        const newCameraPositionY = Math.max(0, Math.min(cameraPositionY, gameContainerHeight - windowHeight));
        gameContainer.scrollTo(newCameraPositionX, newCameraPositionY);
      }

      function checkCollision(position) {
        const cameraPosition = position.clone();

        for (let i = 0; i < scene.children.length; i++) {
          const object = scene.children[i];

          if (object.mazeWall) {
            const wallBoundingBox = new THREE.Box3().setFromObject(object);

            if (wallBoundingBox.containsPoint(cameraPosition)) {
              return true;
            }
          }
        }

        return false;
      }

      let isGameOver = false;

      function checkCollisionPortal(position) {
        const cameraPosition = position.clone();

        for (let i = 0; i < scene.children.length; i++) {
          const object = scene.children[i];

          if (object.mazePortal) {
            const portalBoundingBox = new THREE.Box3().setFromObject(object);

            if (portalBoundingBox.containsPoint(cameraPosition)) {
              gameOver();
              return true;
            }
          }
        }

        return false;
      }

      function moveBackToPreviousPosition() {
        const moveSpeed = 0.5;
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        const backwardMovement = direction.clone().negate().multiplyScalar(moveSpeed);
        const newPosition = camera.position.clone().add(backwardMovement);

        if (!checkCollision(newPosition)) {
          camera.position.copy(newPosition);
        }
      }

      function rotateCameraX(deltaX) {
        const rotationSpeed = 0.01;
        camera.rotation.y -= deltaX * rotationSpeed;
      }

      function showCompletedScreen() {
        const currentTime = Date.now();
        const duration = Math.floor((currentTime - startTime) / 1000);

        const gameOverScreen = document.getElementById('game-over');
        gameOverScreen.style.display = 'block';

        const gameOverTitle = document.createElement('h1');
        gameOverTitle.innerText = 'Congratulations';
        gameOverScreen.appendChild(gameOverTitle);

        const gameOverText = document.createElement('p');
        gameOverText.innerText = `You took ${duration} seconds to clear the maze.`;
        gameOverScreen.appendChild(gameOverText);

        const restartButton = document.createElement('button');
        restartButton.innerText = 'Play Again';
        restartButton.addEventListener('click', restartGame);
        gameOverScreen.appendChild(restartButton);

        playerControls.moveForward = false;
        playerControls.moveBackward = false;
        playerControls.moveLeft = false;
        playerControls.moveRight = false;

        isGameOver = true;
      }

      function restartGame() {
        location.reload();
      }

      const minimapContainer = document.getElementById('minimap-grid');
      const minimapCells = [];

      function initializeMinimap() {
        const cellWidth = 100 / mazeWidth;
        const cellHeight = 100 / mazeHeight;

        for (let row = 0; row < mazeHeight; row++) {
          for (let col = 0; col < mazeWidth; col++) {
            const cell = document.createElement('div');
            cell.className = 'minimap-cell';
            cell.style.width = cellWidth + '%';
            cell.style.height = cellHeight + '%';
            minimapContainer.appendChild(cell);
            minimapCells.push(cell);
          }
        }

        const pos = camera.position.clone();
        const col = Math.floor((pos.x + (mazeWidth / 2) * cellSize - cellSize / 2) / cellSize);
        const row = Math.floor((pos.z + (mazeHeight / 2) * cellSize - cellSize / 2) / cellSize);
        const posIndex = row * mazeWidth + col;
        minimapCells[posIndex].classList.add('player');
        minimapCells[posIndex].classList.add('visited');

        //const portalIndex = portalRow * mazeWidth + portalCol;
        //minimapCells[portalIndex].classList.add('portal');
      }

      initializeMinimap();

      function checkGrid(oldPos, newPos) {
        const oldCol = Math.floor((oldPos.x + (mazeWidth / 2) * cellSize) / cellSize);
        const oldRow = Math.floor((oldPos.z + (mazeHeight / 2) * cellSize) / cellSize);

        const newCol = Math.floor((newPos.x + (mazeWidth / 2) * cellSize) / cellSize);
        const newRow = Math.floor((newPos.z + (mazeHeight / 2) * cellSize) / cellSize);
        if (((oldCol != newCol) || (oldRow != newRow)) && maze[newRow][newCol] != 1) {
          const oldCellIndex = oldRow * mazeWidth + oldCol;
          const newCellIndex = newRow * mazeWidth + newCol;

          if (minimapCells[oldCellIndex]) {
            minimapCells[oldCellIndex].classList.remove('player');
          }
          
          if (minimapCells[newCellIndex]) {
            minimapCells[newCellIndex].classList.add('player');
            minimapCells[newCellIndex].classList.add('visited');
          }

        }
      }

      function update() {
        if (isGameOver) {
          return;
        }
        const moveSpeed = 0.6;

        if (playerControls.moveForward) {
          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);
          const newPosition = camera.position.clone().addScaledVector(direction, moveSpeed);
          const oldPosition = camera.position.clone();

          if (!checkCollision(newPosition)) {
            camera.position.copy(newPosition);
            checkCollisionPortal(newPosition);
            checkGrid(oldPosition, newPosition);
          } else {
            playerControls.moveForward = false;
            moveBackToPreviousPosition();
          }
        }

        if (playerControls.moveBackward) {
          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);
          const newPosition = camera.position.clone().addScaledVector(direction, -moveSpeed);
          const oldPosition = camera.position.clone();

          if (!checkCollision(newPosition)) {
            camera.position.copy(newPosition);
            checkCollisionPortal(newPosition);
            checkGrid(oldPosition, newPosition);
          } else {
            playerControls.moveBackward = false;
            moveBackToPreviousPosition();
          }
        }

        if (playerControls.moveLeft) {
          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);
          const perpendicular = new THREE.Vector3(direction.z, 0, -direction.x);
          const newPosition = camera.position.clone().addScaledVector(perpendicular, moveSpeed);
          const oldPosition = camera.position.clone();

          if (!checkCollision(newPosition)) {
            camera.position.copy(newPosition);
            checkCollisionPortal(newPosition);
            checkGrid(oldPosition, newPosition);
          } else {
            playerControls.moveLeft = false;
            moveBackToPreviousPosition();
          }
        }

        if (playerControls.moveRight) {
          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);
          const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
          const newPosition = camera.position.clone().addScaledVector(perpendicular, moveSpeed);
          const oldPosition = camera.position.clone();

          if (!checkCollision(newPosition)) {
            camera.position.copy(newPosition);
            checkCollisionPortal(newPosition);
            checkGrid(oldPosition, newPosition);
          } else {
            playerControls.moveRight = false;
            moveBackToPreviousPosition();
          }
        }
      }
      
      function animate() {
          requestAnimationFrame(animate);
          update();
          renderer.render(scene, camera);
      }

      animate();

      function generateRandomMaze(width, height) {
        var maze = [];
        while(1) {
          maze = [];

          for (let row = 0; row < height; row++) {
            const mazeRow = [];
            for (let col = 0; col < width; col++) {
              mazeRow.push(1);
            }
            maze.push(mazeRow);
          }

          let startX = Math.floor(Math.random() * (width - 2)) + 1;
          let startY = Math.floor(Math.random() * (height - 2)) + 1;

          const stack = [];
          stack.push({ x: startX, y: startY });

          while (stack.length > 0) {
            const current = stack.pop();
            const { x, y } = current;

            maze[y][x] = 0;

            const neighbors = [];

            if (y - 2 >= 1) neighbors.push({ x: x, y: y - 2 }); // Top
            if (y + 2 < height - 1) neighbors.push({ x: x, y: y + 2 }); // Bottom
            if (x - 2 >= 1) neighbors.push({ x: x - 2, y: y }); // Left
            if (x + 2 < width - 1) neighbors.push({ x: x + 2, y: y }); // Right

            for (let i = neighbors.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [neighbors[i], neighbors[j]] = [neighbors[j], neighbors[i]];
            }

            for (const neighbor of neighbors) {
              const { x: nx, y: ny } = neighbor;

              if (maze[ny][nx] === 1) {
                maze[y + (ny - y) / 2][x + (nx - x) / 2] = 0;

                maze[ny][nx] = 0;

                stack.push({ x: nx, y: ny });
              }
            }
          }

          maze[startY][startX] = 2;

          const minDistance = Math.floor(2 / 3 * Math.max(width, height));
          console.log("Min distance : ", minDistance);
          let targetX = -1, targetY = -1;
          let counter = 0;
          do {
            targetX = Math.floor(Math.random() * (width - 2)) + 1;
            targetY = Math.floor(Math.random() * (height - 2)) + 1;
            counter++;
            if (counter > 10) {
              break;
            }
          } while ((Math.abs(targetX - startX) + Math.abs(targetY - startY) < minDistance) || maze[targetX][targetY] != 0);
          if ((targetX != -1) && (targetY != -1)) {
            maze[targetY][targetX] = 3;
            break;
          }
        }
        return maze;
      }
    }

  </script>
</body>
</html>
