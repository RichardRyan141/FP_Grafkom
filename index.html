<!DOCTYPE html>
<html>
<head>
  <title>Escape Maze!!</title>
  <link rel="icon" type="image/png" href="assets/favicon.ico">
  <style>
    #maze-container {
      position: relative;
      width: 800px;
      height: 600px;
    }

    #maze-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 800px;
      height: 600px;
    }

    #minimap-grid {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .minimap-cell {
      position: absolute;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      border: 1px solid white;
    }

    #player-position {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      border: 2px solid red;
      pointer-events: none;
    }

    #enemy-position {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      border: 2px solid blue;
      pointer-events: none;
    }

    #start-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 999;
    }

    #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 999;
      display: none;
    }

    #game-over p {
      color: white;
      font-size: 24px;
      margin-bottom: 10px;
    }

    #game-over button {
      padding: 10px 20px;
      background-color: #4caf50;
      border: none;
      color: white;
      font-weight: bold;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="maze-container">
    <div id="minimap">
      <div id="minimap-grid"></div>
      <div id="player-position"></div>
      <div id="enemy-position"></div>
    </div>
    <div id="start-screen">
      <h1>Welcome to Escape Maze!</h1>
      <p>Please select the dimensions of the maze:</p>
      <input type="number" id="maze-width" min="5" max="30" placeholder="Width" />
      <input type="number" id="maze-height" min="5" max="30" placeholder="Height" />
      <button id="start-button">Start Game</button>
    </div>
  </div>
  
  <div id="game-over">
    <p id="game-over-text"></p>
    <button id="restart-button">Restart Game</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
  <script>
    let startTime = Date.now();

    let mazeWidth = 0;
    let mazeHeight = 0;

    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over');
    const gameOverText = document.getElementById('game-over-text');
    const restartButton = document.getElementById('restart-button');
    const mazeContainer = document.getElementById('maze-container');
    const mazeWidthInput = document.getElementById('maze-width');
    const mazeHeightInput = document.getElementById('maze-height');
    const startButton = document.getElementById('start-button');

    startButton.addEventListener('click', () => {
      mazeWidth = parseInt(mazeWidthInput.value);
      mazeHeight = parseInt(mazeHeightInput.value);
      startScreen.style.display = 'none';
      mazeContainer.style.display = 'block';
      initializeMaze();
    });

    const gameOver = () => {
      const timeTaken = calculateTimeTaken();
      gameOverText.textContent = `Congratulations!\nYou took ${timeTaken} seconds to clear the maze`;
      gameOverScreen.style.display = 'flex';
      mazeContainer.style.pointerEvents = 'none';
    };

    const calculateTimeTaken = () => {
      const currentTime = new Date();
      const timeDiff = Math.round((currentTime - startTime) / 1000); // Time difference in seconds
      return timeDiff;
    };

    restartButton.addEventListener("click", () => {
      location.reload(); // Reload the page
    });


    function initializeMaze() {
      const cellSize = 50;

      // Define maze structure
      const maze = generateRandomMaze(mazeWidth, mazeHeight);
      console.log(maze);

      // Initialize the scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(800, 600);
      document.getElementById('maze-container').appendChild(renderer.domElement);

      // Load textures
      const groundTexture = new THREE.TextureLoader().load('assets/textures/old-wood.jpg');
      const wallTexture = new THREE.TextureLoader().load('assets/textures/old-wood-2.jpg');
      const ceilingTexture = new THREE.TextureLoader().load('assets/textures/ceilings.png');
      const portalTexture = new THREE.TextureLoader().load('assets/textures/portal.jpg');
      // const groundTexture = new THREE.TextureLoader().load('assets/textures/old-wood.jpg');
      // const wallTexture = new THREE.TextureLoader().load('assets/textures/horror-wall.jpg');
      // const ceilingTexture = new THREE.TextureLoader().load('assets/textures/antique.jpg');
      
      //const enemyTexture = new THREE.TextureLoader().load('assets/textures/enemy.png'); // Enemy sprite texture

      // Create materials for maze elements
      const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture });
      const floorMaterial = new THREE.MeshBasicMaterial({ map: groundTexture });
      const ceilingMaterial = new THREE.MeshBasicMaterial({ map: ceilingTexture });
      const portalMaterial = new THREE.MeshBasicMaterial({ map: portalTexture });
      //const enemyMaterial = new THREE.MeshBasicMaterial({ map: enemyTexture }); // Enemy sprite material

      // Create maze objects
      for (let row = 0; row < mazeHeight; row++) {
        for (let col = 0; col < mazeWidth; col++) {
          const cell = maze[row][col];
          if (cell === 1) {
            const wall = new THREE.BoxGeometry(cellSize, cellSize * 2, cellSize);
            const wallMesh = new THREE.Mesh(wall, wallMaterial);
            wallMesh.position.x = col * cellSize - (mazeWidth / 2) * cellSize + cellSize / 2;
            wallMesh.position.y = cellSize;
            wallMesh.position.z = row * cellSize - (mazeHeight / 2) * cellSize + cellSize / 2;
            wallMesh.mazeWall = true; // Set custom property to identify maze walls
            scene.add(wallMesh);
          } else {
            const floor = new THREE.PlaneGeometry(cellSize, cellSize);
            const floorMesh = new THREE.Mesh(floor, floorMaterial);
            floorMesh.position.x = col * cellSize - (mazeWidth / 2) * cellSize + cellSize / 2;
            floorMesh.position.y = 0;
            floorMesh.position.z = row * cellSize - (mazeHeight / 2) * cellSize + cellSize / 2;
            floorMesh.rotation.x = -Math.PI / 2;
            scene.add(floorMesh);

            const ceiling = new THREE.PlaneGeometry(cellSize, cellSize);
            const ceilingMesh = new THREE.Mesh(ceiling, ceilingMaterial);
            ceilingMesh.position.x = col * cellSize - (mazeWidth / 2) * cellSize + cellSize / 2;
            ceilingMesh.position.y = cellSize * 2;
            ceilingMesh.position.z = row * cellSize - (mazeHeight / 2) * cellSize + cellSize / 2;
            ceilingMesh.rotation.x = Math.PI / 2;
            scene.add(ceilingMesh);

            if (cell == 2) {
              camera.position.set(floorMesh.position.x, cellSize / 2, floorMesh.position.z );
            }

            if (cell == 3) {
              const portal = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
              const portalMesh = new THREE.Mesh(portal, portalMaterial);
              portalMesh.position.x = col * cellSize - (mazeWidth / 2) * cellSize + cellSize / 2;
              portalMesh.position.y = cellSize/2;
              portalMesh.position.z = row * cellSize - (mazeHeight / 2) * cellSize + cellSize / 2;
              portalMesh.mazePortal = true;
              scene.add(portalMesh);
            }
          }
        }
      }

      // Player controls
      const playerControls = {
        moveForward: false,
        moveBackward: false,
        moveLeft: false,
        moveRight: false,
      };

      let isMousePressed = false;
      let previousMouseX = 0;

      document.addEventListener('keydown', (event) => {
        handlePlayerControls(event.keyCode, true);
      });

      document.addEventListener('keyup', (event) => {
        handlePlayerControls(event.keyCode, false);
      });

      document.addEventListener('mousedown', (event) => {
        if (event.button === 0) {
          isMousePressed = true;
          previousMouseX = event.clientX;
        }
      });

      document.addEventListener('mouseup', (event) => {
        if (event.button === 0) {
          isMousePressed = false;
        }
      });

      document.addEventListener('mousemove', (event) => {
        if (isMousePressed) {
          const mouseDeltaX = event.clientX - previousMouseX;
          previousMouseX = event.clientX;
          rotateCameraX(mouseDeltaX);
        }
      });


      function handlePlayerControls(keyCode, isPressed) {
        switch (keyCode) {
          case 87: // W key
            playerControls.moveForward = isPressed;
            break;
          case 38: // Arrow up
            handleKeyPress(38);
            break;
          case 83: // S key
            playerControls.moveBackward = isPressed;
            break;
          case 40: // Arrow down
            handleKeyPress(40);
            break;
          case 65: // A key
            playerControls.moveLeft = isPressed;
            break;
          case 37: // Arrow left
            handleKeyPress(37);
            break;
          case 68: // D key
            playerControls.moveRight = isPressed;
            break;
          case 39: // Arrow right
            handleKeyPress(39);
            break;
          default:
            // Handle other key codes here if needed
            break;
        }
      }

      // Fungsi untuk menangkap peristiwa tombol ditekan
      function handleKeyPress(keyCode) {

        // Mendapatkan elemen kotak game
        const gameContainer = document.getElementById('game-container');

        // Mendapatkan posisi kamera saat ini
        let cameraPositionX = gameContainer.scrollLeft;
        let cameraPositionY = gameContainer.scrollTop;

        // Mendapatkan ukuran kotak game
        const gameContainerWidth = gameContainer.offsetWidth;
        const gameContainerHeight = gameContainer.offsetHeight;

        // Mendapatkan ukuran jendela browser
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Menghitung posisi tengah jendela browser
        const windowCenterX = windowWidth / 2;
        const windowCenterY = windowHeight / 2;

        // Menghitung posisi tengah kotak game
        const gameCenterX = gameContainerWidth / 2;
        const gameCenterY = gameContainerHeight / 2;

        // Mengubah posisi kamera berdasarkan tombol yang ditekan
        if (keyCode === 38) { // PgUp
          cameraPositionY -= windowCenterY;
        } else if (keyCode === 40) { // PgDown
          cameraPositionY += windowCenterY;
        } else if (keyCode === 37) { // PgLeft
          cameraPositionX -= windowCenterX;
        } else if (keyCode === 39) { // PgRight
          cameraPositionX += windowCenterX;
        }

        // Mengubah properti posisi kamera
        const newCameraPositionX = Math.max(0, Math.min(cameraPositionX, gameContainerWidth - windowWidth));
        const newCameraPositionY = Math.max(0, Math.min(cameraPositionY, gameContainerHeight - windowHeight));
        gameContainer.scrollTo(newCameraPositionX, newCameraPositionY);
      }


      /*const enemySize = cellSize * 0.8; // Adjust the size of the enemy sprite as desired
      const enemyGeometry = new THREE.BoxGeometry(enemySize*0.5, enemySize, enemySize*0.3);
      const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);

      function spawnEnemy() {
        let validPosition = false;
        let enemyPosition;

        // Generate a random position for the enemy
        while (!validPosition) {
          const row = Math.floor(Math.random() * mazeHeight);
          const col = Math.floor(Math.random() * mazeWidth);

          // Check if the position is inside a wall or too close to the camera
          const distance = Math.sqrt((row * cellSize - camera.position.z) ** 2 + (col * cellSize - camera.position.x) ** 2);
          if (!maze[row][col] && distance >= 100) {
            validPosition = true;
            enemyPosition = { row, col };
          }
        }

        // Set enemy position and update enemyMesh
        enemyMesh.position.x = enemyPosition.col * cellSize - (mazeWidth / 2) * cellSize + cellSize / 2;
        enemyMesh.position.z = enemyPosition.row * cellSize - (mazeHeight / 2) * cellSize + cellSize / 2;
        enemyMesh.position.y = cellSize*0.4;
      }

      spawnEnemy();

      enemyMesh.scale.x = 0.5;
      scene.add(enemyMesh);*/


      function checkCollision(position) {
        const cameraPosition = position.clone();

        // Iterate through all maze walls
        for (let i = 0; i < scene.children.length; i++) {
          const object = scene.children[i];

          // Check if the object is a maze wall
          if (object.mazeWall) {
            const wallBoundingBox = new THREE.Box3().setFromObject(object);

            if (wallBoundingBox.containsPoint(cameraPosition)) {
              return true; // Collision occurs
            }
          }
        }

        return false; // No collision
      }

      let isGameOver = false;

      function checkCollisionPortal(position) {
        const cameraPosition = position.clone();

        // Iterate through all maze walls
        for (let i = 0; i < scene.children.length; i++) {
          const object = scene.children[i];

          // Check if the object is a portal
          if (object.mazePortal) {
            const portalBoundingBox = new THREE.Box3().setFromObject(object);

            if (portalBoundingBox.containsPoint(cameraPosition)) {
              gameOver();
              return true; // Collision occurs
            }
          }
        }

        return false; // No collision
      }

      /*function checkCollisionEnemy(position) {
          const cameraPosition = position.clone();
          
          // Check collision with enemy
          const enemyBoundingBox = new THREE.Box3().setFromObject(enemyMesh);
          
          if (enemyBoundingBox.containsPoint(cameraPosition)) {
              showGameOverScreen(); // Collision with enemy
              return true;
          }
          
          return false; // No collision
      }*/

      function moveBackToPreviousPosition() {
        const moveSpeed = 0.5;
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        const backwardMovement = direction.clone().negate().multiplyScalar(moveSpeed);
        const newPosition = camera.position.clone().add(backwardMovement);

        if (!checkCollision(newPosition)) {
          camera.position.copy(newPosition);
        }
      }

      function rotateCameraX(deltaX) {
        const rotationSpeed = 0.01;
        camera.rotation.y -= deltaX * rotationSpeed;
      }

      function showCompletedScreen() {
        const currentTime = Date.now();
        const duration = Math.floor((currentTime - startTime) / 1000); // Calculate duration in seconds

        const gameOverScreen = document.getElementById('game-over');
        gameOverScreen.style.display = 'block';

        const gameOverTitle = document.createElement('h1');
        gameOverTitle.innerText = 'Congratulations';
        gameOverScreen.appendChild(gameOverTitle);

        const gameOverText = document.createElement('p');
        gameOverText.innerText = `You took ${duration} seconds to clear the maze.`;
        gameOverScreen.appendChild(gameOverText);

        const restartButton = document.createElement('button');
        restartButton.innerText = 'Play Again';
        restartButton.addEventListener('click', restartGame);
        gameOverScreen.appendChild(restartButton);

        // Disable player controls
        playerControls.moveForward = false;
        playerControls.moveBackward = false;
        playerControls.moveLeft = false;
        playerControls.moveRight = false;

        // Stop enemy movement
        isGameOver = true;
      }

      function restartGame() {
        location.reload();
      }

      // Update function
      function update() {
        if (isGameOver) {
          return;
        }
        const moveSpeed = 0.6;

        if (playerControls.moveForward) {
          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);
          const newPosition = camera.position.clone().addScaledVector(direction, moveSpeed);

          if (!checkCollision(newPosition)) {
            camera.position.copy(newPosition);
            checkCollisionPortal(newPosition);
          } else {
            playerControls.moveForward = false; // Disable forward movement
            moveBackToPreviousPosition();
          }
        }

        if (playerControls.moveBackward) {
          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);
          const newPosition = camera.position.clone().addScaledVector(direction, -moveSpeed);

          if (!checkCollision(newPosition)) {
            camera.position.copy(newPosition);
            checkCollisionPortal(newPosition);
          } else {
            playerControls.moveBackward = false; // Disable forward movement
            moveBackToPreviousPosition();
          }
        }

        if (playerControls.moveLeft) {
          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);
          const perpendicular = new THREE.Vector3(direction.z, 0, -direction.x); // Calculate perpendicular vector
          const newPosition = camera.position.clone().addScaledVector(perpendicular, moveSpeed);

          if (!checkCollision(newPosition)) {
            camera.position.copy(newPosition);
            checkCollisionPortal(newPosition);
          } else {
            playerControls.moveLeft = false; // Disable forward movement
            moveBackToPreviousPosition();
          }
        }

        if (playerControls.moveRight) {
          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);
          const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x); // Calculate perpendicular vector
          const newPosition = camera.position.clone().addScaledVector(perpendicular, moveSpeed);

          if (!checkCollision(newPosition)) {
            camera.position.copy(newPosition);
            checkCollisionPortal(newPosition);
          } else {
            playerControls.moveRight = false; // Disable forward movement
            moveBackToPreviousPosition();
          }
        }
      }
      
      /*// Variables to control the smooth movement
      let smoothMoveFrame = 0;
      const totalSmoothMoveFrames = 10; // Adjust this value to control the smoothness

      function moveEnemy() {
        if (isGameOver) {
          return;
        }
          const randomNum = Math.floor(Math.random() * 20) + 1;
          if (randomNum <= 10) {
              const moveSpeed = 2;
              const directions = [
                  new THREE.Vector3(1, 0, 0),   // Right
                  new THREE.Vector3(-1, 0, 0),  // Left
                  new THREE.Vector3(0, 0, 1),   // Forward
                  new THREE.Vector3(0, 0, -1)   // Backward
              ];

              const randomIndex = Math.floor(Math.random() * directions.length);
              const enemyDirection = directions[randomIndex];

              const newPosition = enemyMesh.position.clone().addScaledVector(enemyDirection, moveSpeed);

              if (!checkCollision(newPosition)) {
                  enemyMesh.position.copy(newPosition);
              }
          }
      }*/

      const minimapContainer = document.getElementById('minimap');
      const playerPositionIndicator = document.getElementById('player-position');
      //const enemyPositionIndicator = document.getElementById('enemy-position');

      const minimapGrid = document.getElementById('minimap-grid');
      minimapGrid.style.gridTemplateColumns = `repeat(${mazeWidth}, 1fr)`;
      minimapGrid.style.gridTemplateRows = `repeat(${mazeHeight}, 1fr)`;

      for (let row = 0; row < mazeHeight; row++) {
        for (let col = 0; col < mazeWidth; col++) {
          const cellType = maze[row][col];
          const cell = document.createElement('div');
          cell.className = 'minimap-cell';
          cell.style.backgroundColor = cellType === 0 ? 'black' : 'white';
          minimapGrid.appendChild(cell);
        }
      }
      function updateMinimap() {
        // Calculate minimap scale
        const minimapScale = Math.min(minimapContainer.offsetWidth / mazeWidth, minimapContainer.offsetHeight / mazeHeight);

        // Update player position indicator
        const playerX = camera.position.x + (mazeWidth * cellSize) / 2;
        const playerZ = camera.position.z + (mazeHeight * cellSize) / 2;
        playerPositionIndicator.style.transform = `translate(${playerX * minimapScale}px, ${playerZ * minimapScale}px)`;

        // Update enemy position indicator
        /*const enemyX = enemyMesh.position.x + (mazeWidth * cellSize) / 2;
        const enemyZ = enemyMesh.position.z + (mazeHeight * cellSize) / 2;
        enemyPositionIndicator.style.transform = `translate(${enemyX * minimapScale}px, ${enemyZ * minimapScale}px)`;
        */
      }


      //let lastEnemyMoveTime = Date.now();

      function animate() {
          requestAnimationFrame(animate);
          update();
          /*const currentTime = Date.now();

          if (currentTime - lastEnemyMoveTime >= 100) {
              moveEnemy();
              lastEnemyMoveTime = currentTime;
          }*/
          updateMinimap();
          renderer.render(scene, camera);
      }

      // Start the animation
      animate();

      function generateRandomMaze(width, height) {
        const maze = [];

        // Initialize the maze grid with walls
        for (let row = 0; row < height; row++) {
          const mazeRow = [];
          for (let col = 0; col < width; col++) {
            mazeRow.push(1);
          }
          maze.push(mazeRow);
        }

        // Randomly select a starting point
        let startX = Math.floor(Math.random() * (width - 2)) + 1;
        let startY = Math.floor(Math.random() * (height - 2)) + 1;

        const stack = [];
        stack.push({ x: startX, y: startY });

        while (stack.length > 0) {
          const current = stack.pop();
          const { x, y } = current;

          // Mark the current cell as visited
          maze[y][x] = 0;

          // Get the neighboring cells
          const neighbors = [];

          if (y - 2 >= 1) neighbors.push({ x: x, y: y - 2 }); // Top
          if (y + 2 < height - 1) neighbors.push({ x: x, y: y + 2 }); // Bottom
          if (x - 2 >= 1) neighbors.push({ x: x - 2, y: y }); // Left
          if (x + 2 < width - 1) neighbors.push({ x: x + 2, y: y }); // Right

          // Shuffle the neighboring cells randomly
          for (let i = neighbors.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [neighbors[i], neighbors[j]] = [neighbors[j], neighbors[i]];
          }

          for (const neighbor of neighbors) {
            const { x: nx, y: ny } = neighbor;

            // Check if the neighbor is unvisited
            if (maze[ny][nx] === 1) {
              // Remove the wall between the current cell and the neighbor
              maze[y + (ny - y) / 2][x + (nx - x) / 2] = 0;

              // Mark the neighbor as visited
              maze[ny][nx] = 0;

              // Push the neighbor to the stack
              stack.push({ x: nx, y: ny });
            }
          }
        }

        // Set the starting point
        maze[startY][startX] = 2;

        const maxDistance = Math.floor(2 / 3 * Math.max(width, height));
        let targetX, targetY;
        do {
          targetX = Math.floor(Math.random() * (width - 2)) + 1;
          targetY = Math.floor(Math.random() * (height - 2)) + 1;
        } while (Math.abs(targetX - startX) + Math.abs(targetY - startY) < maxDistance);

        // Change the cell to 3
        maze[targetY][targetX] = 3;


        return maze;
      }
    }

  </script>
</body>
</html>
